#BICList[[MinBIC]]
#FormList[[MinBIC]]
#Indice del modelo con menor AIC
MinAIC=which.min(unlist(AICList))
ModMinAIC=ModelList[[MinAIC]]
summary(ModMinAIC)
ModMinAIC$family
("go")
AICList[[MinAIC]]
BICList[[MinAIC]]
FormList[[MinAIC]]
#Indice del modelo con menor AIC
MinAIC=which.min(unlist(AICList))
ModMinAIC=ModelList[[MinAIC]]
summary(ModMinAIC)
ModMinAIC$family
(AIC)
AICList[[MinAIC]]
BICList[[MinAIC]]
FormList[[MinAIC]]
#Indice del modelo con menor AIC
MinAIC=which.min(unlist(AICList))
ModMinAIC=ModelList[[MinAIC]]
summary(ModMinAIC)
ModMinAIC$family
AICList[[MinAIC]]
BICList[[MinAIC]]
FormList[[MinAIC]]
#Indice del modelo con menor AIC
MinAIC=which.min(unlist(AICList))
ModMinAIC=ModelList[[MinAIC]]
summary(ModMinAIC)
ModMinAIC$family
AICList[[MinAIC]]
BICList[[MinAIC]]
FormList[[MinAIC]]
summar(glm(formula = bpsystol ~ age+sex+I(bmi^(2)), family = inverse.gaussian(link = identity ), data = datos))
summary(glm(formula = bpsystol ~ age+sex+I(bmi^(2)), family = inverse.gaussian(link = identity ), data = datos))
#El modelo con menor AIC
MinAIC=which.min(unlist(AICList))
ModMinAIC=ModelList[[MinAIC]]
summary(ModMinAIC)
ModMinAIC$family
AICList[[MinAIC]]
BICList[[MinAIC]]
FormList[[MinAIC]]
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(stargazer)
library(kableExtra)
datos<-read_csv("Preg1B.csv", show_col_types = FALSE)
datos$sex<-factor(datos$sex) #declaramos la variable como factor
#Realizamos un relevel para poner como referencia "1"
datos$sex<-relevel(datos$sex,"1")
#Seleccionar un modelo entre un conjunto de posibles glm, mediante mallas
#Comp lineal: a)transf BoxTidwell(potencias) a x y b) polinomio sobre x
#Mallas para el valor de potencia y grado de polinomio:
malla=seq(from = 1, to = 5, by = 1)
Poli <- cbind("poly", malla)
malla=seq(from = -3, to = 3, by = .5)
Pot <- cbind("pot", malla)
CompLin=rbind(Poli, Pot)
#Componente aleatorio: Y es continua y positiva, tenemos tres opciones:
#Malla con distribucion Normal, Gausiana e Inversa Gausiana
Distribuciones=c("gaussian", "Gamma", "inverse.gaussian")
#Funcion liga:inverse, identity, log, y 1/mu^2(solo para IG)
FunLigas=c("identity", "log", "inverse", "1/mu^2")
#Declaramos longitud o dimensión de los vectores
nFunLigas=length(FunLigas)
nDist=length(Distribuciones)
nCompLin=dim(CompLin)[1]
#Creación de variables para guardar resultados
ModelList=list(NA)  #guardar resultados del ajuste, objeto glm
AICList=list(NA)    #guardar el AIC del modelo
BICList=list(NA)    #guardar el BIC del modelo
FormList=list(NA)   #guardar la formula usada para el ajuste
#Modelos 18*2*3+18*1*4(tres funciones ligas para 2 distrib y 4 para una, IG)
#Generamos los cíclos y combinaciones de las mallas
index=0
for(k in 1:nCompLin){
#definimos componente lineal y formula
if(CompLin[k,1]=="poly"){
formstring=paste0("bpsystol ~ age+sex+poly(bmi,",  CompLin[k,2], ", raw=TRUE)")
}else{
if(CompLin[k,2]==0){
formstring=paste0("bpsystol ~ age+sex+I(log(bmi))")}else
{
formstring=paste0("bpsystol ~ age+sex+I(bmi^(",  CompLin[k,2], "))")}
}
form <- as.formula(formstring)
for(j in 1:nDist){
for(l in 1:nFunLigas){
#definicion del argumento family
if(FunLigas[l]=="1/mu^2"){
if(Distribuciones[j]=="inverse.gaussian"){
index=index+1
Dist=get(Distribuciones[j])  #obtener la funcion a usar
Mod.A.Prueba=glm(form, data=datos, family = Dist(link=FunLigas[l]))
ModelList[[index]]=Mod.A.Prueba
AICList[[index]]=AIC(Mod.A.Prueba)
BICList[[index]]=BIC(Mod.A.Prueba)
FormList[[index]]=formstring
}
}else{
index=index+1
Dist=get(Distribuciones[j])
Mod.A.Prueba=glm(form, data=datos, family = Dist(link=FunLigas[l]))
ModelList[[index]]=Mod.A.Prueba
AICList[[index]]=AIC(Mod.A.Prueba)
BICList[[index]]=BIC(Mod.A.Prueba)
FormList[[index]]=formstring
}
}
}
}
#El modelo con menor AIC
MinAIC=which.min(unlist(AICList))
ModMinAIC=ModelList[[MinAIC]]
summary(ModMinAIC)
ModMinAIC$family
AICList[[MinAIC]]
BICList[[MinAIC]]
FormList[[MinAIC]]
summary(glm(formula = bpsystol ~ age+sex+I(bmi^(2)), family = inverse.gaussian(link = identity ), data = datos))
summary(glm(formula = bpsystol ~ age+sex+bmi, family = inverse.gaussian(link = identity ), data = datos))
ModMinAIC$family
#AICList[[MinAIC]]
#BICList[[MinAIC]]
FormList[[MinAIC]]
ModMinAIC$family
AICList[[MinAIC]]
#BICList[[MinAIC]]
FormList[[MinAIC]]
summary(glm(formula = bpsystol ~ age+sex+bmi, family = inverse.gaussian(link = identity ), data = datos))
summary(glm(formula = bpsystol ~ age+sex+bmi, family = inverse.gaussian(link = identity ), data = datos))
modelo_glm1<-glm(formula = bpsystol ~ age+sex+bmi, family = inverse.gaussian(link = identity ), data = datos)
summary(modelo_glm1)
exp(0.004)
exp(−0.049)
exp(-0.049)
exp(0.049)
par(mfrow = c(2, 2))
plot(modelo_glm1)
#par(mfrow = c(2, 2))
#####check_model function of performance package: Grphs####
pkgs <- c(
"flextable", "performance", "see", "lmtest", "ggplot2",
"qqplotr", "ggrepel", "patchwork", "boot", "rempsyc", "report"
)
#install.packages(pkgs)
library(flextable)
library(performance)
library(see)
library(lmtest)
library(qqplotr)
library(ggrepel)
library(patchwork)
library(boot)
library(rempsyc)
library(report)
#check_model(modelo1) #check_model() function of the performance package
###check_model function of performance package: p-values ###
#check_collinearity(modelo1) # VIF
#check_autocorrelation(modelo1) #  Autocorrelated residuals p value
#check_heteroscedasticity(modelo1) # non-constant error variance (heteroscedasticity): p value
#check_outliers(modelo1) # Outliers method and threshold: cook
# check_normality(modelo1) # Normality of residuals p value
table_tests2<-nice_assumptions(modelo_glm1)
table_tests_fin2<-subset(table_tests2, select = -c(Model,Diagnostic) )
kable(t(table_tests_fin2)) %>%
kable_styling(bootstrap_options = "striped", full_width = F)
modelo_glm1<-glm(formula = bpsystol ~ age+sex+I(bmi^(1.5), family = inverse.gaussian(link = identity ), data = datos)
summary(modelo_glm1)
modelo_glm1<-glm(formula = bpsystol ~ age+sex+I(bmi^(1.5)), family = inverse.gaussian(link = identity ), data = datos)
summary(modelo_glm1)
par(mfrow = c(2, 2))
plot(modelo_glm1)
#par(mfrow = c(2, 2))
#####check_model function of performance package: Grphs####
pkgs <- c(
"flextable", "performance", "see", "lmtest", "ggplot2",
"qqplotr", "ggrepel", "patchwork", "boot", "rempsyc", "report"
)
#install.packages(pkgs)
library(flextable)
library(performance)
library(see)
library(lmtest)
library(qqplotr)
library(ggrepel)
library(patchwork)
library(boot)
library(rempsyc)
library(report)
#check_model(modelo1) #check_model() function of the performance package
###check_model function of performance package: p-values ###
#check_collinearity(modelo1) # VIF
#check_autocorrelation(modelo1) #  Autocorrelated residuals p value
#check_heteroscedasticity(modelo1) # non-constant error variance (heteroscedasticity): p value
#check_outliers(modelo1) # Outliers method and threshold: cook
# check_normality(modelo1) # Normality of residuals p value
table_tests2<-nice_assumptions(modelo_glm1)
table_tests_fin2<-subset(table_tests2, select = -c(Model,Diagnostic) )
kable(t(table_tests_fin2)) %>%
kable_styling(bootstrap_options = "striped", full_width = F)
modelo_glm1<-glm(formula = bpsystol ~ age+sex+I(bmi^(2)), family = inverse.gaussian(link = identity ), data = datos)
summary(modelo_glm1)
par(mfrow = c(2, 2))
plot(modelo_glm1)
#par(mfrow = c(2, 2))
#####check_model function of performance package: Grphs####
pkgs <- c(
"flextable", "performance", "see", "lmtest", "ggplot2",
"qqplotr", "ggrepel", "patchwork", "boot", "rempsyc", "report"
)
#install.packages(pkgs)
library(flextable)
library(performance)
library(see)
library(lmtest)
library(qqplotr)
library(ggrepel)
library(patchwork)
library(boot)
library(rempsyc)
library(report)
#check_model(modelo1) #check_model() function of the performance package
###check_model function of performance package: p-values ###
#check_collinearity(modelo1) # VIF
#check_autocorrelation(modelo1) #  Autocorrelated residuals p value
#check_heteroscedasticity(modelo1) # non-constant error variance (heteroscedasticity): p value
#check_outliers(modelo1) # Outliers method and threshold: cook
# check_normality(modelo1) # Normality of residuals p value
table_tests2<-nice_assumptions(modelo_glm1)
table_tests_fin2<-subset(table_tests2, select = -c(Model,Diagnostic) )
kable(t(table_tests_fin2)) %>%
kable_styling(bootstrap_options = "striped", full_width = F)
modelo_glm1<-glm(formula = bpsystol ~ age+sex+bmi, family = inverse.gaussian(link = log ), data = datos)
summary(modelo_glm1)
par(mfrow = c(2, 2))
plot(modelo_glm1)
#par(mfrow = c(2, 2))
#####check_model function of performance package: Grphs####
pkgs <- c(
"flextable", "performance", "see", "lmtest", "ggplot2",
"qqplotr", "ggrepel", "patchwork", "boot", "rempsyc", "report"
)
#install.packages(pkgs)
library(flextable)
library(performance)
library(see)
library(lmtest)
library(qqplotr)
library(ggrepel)
library(patchwork)
library(boot)
library(rempsyc)
library(report)
#check_model(modelo1) #check_model() function of the performance package
###check_model function of performance package: p-values ###
#check_collinearity(modelo1) # VIF
#check_autocorrelation(modelo1) #  Autocorrelated residuals p value
#check_heteroscedasticity(modelo1) # non-constant error variance (heteroscedasticity): p value
#check_outliers(modelo1) # Outliers method and threshold: cook
# check_normality(modelo1) # Normality of residuals p value
table_tests2<-nice_assumptions(modelo_glm1)
table_tests_fin2<-subset(table_tests2, select = -c(Model,Diagnostic) )
kable(t(table_tests_fin2)) %>%
kable_styling(bootstrap_options = "striped", full_width = F)
modelo_glm1<-glm(formula = bpsystol ~ age+sex+bmi, family = inverse.gaussian(link = identity ), data = datos)
summary(modelo_glm1)
par(mfrow = c(2, 2))
plot(modelo_glm1)
#par(mfrow = c(2, 2))
#####check_model function of performance package: Grphs####
pkgs <- c(
"flextable", "performance", "see", "lmtest", "ggplot2",
"qqplotr", "ggrepel", "patchwork", "boot", "rempsyc", "report"
)
#install.packages(pkgs)
library(flextable)
library(performance)
library(see)
library(lmtest)
library(qqplotr)
library(ggrepel)
library(patchwork)
library(boot)
library(rempsyc)
library(report)
#check_model(modelo1) #check_model() function of the performance package
###check_model function of performance package: p-values ###
#check_collinearity(modelo1) # VIF
#check_autocorrelation(modelo1) #  Autocorrelated residuals p value
#check_heteroscedasticity(modelo1) # non-constant error variance (heteroscedasticity): p value
#check_outliers(modelo1) # Outliers method and threshold: cook
# check_normality(modelo1) # Normality of residuals p value
table_tests2<-nice_assumptions(modelo_glm1)
table_tests_fin2<-subset(table_tests2, select = -c(Model,Diagnostic) )
kable(t(table_tests_fin2)) %>%
kable_styling(bootstrap_options = "striped", full_width = F)
modelo_glm1<-glm(formula = bpsystol ~ age+sex+bmi, family = gaussian(link = identity ), data = datos)
summary(modelo_glm1)
par(mfrow = c(2, 2))
plot(modelo_glm1)
#par(mfrow = c(2, 2))
#####check_model function of performance package: Grphs####
pkgs <- c(
"flextable", "performance", "see", "lmtest", "ggplot2",
"qqplotr", "ggrepel", "patchwork", "boot", "rempsyc", "report"
)
#install.packages(pkgs)
library(flextable)
library(performance)
library(see)
library(lmtest)
library(qqplotr)
library(ggrepel)
library(patchwork)
library(boot)
library(rempsyc)
library(report)
#check_model(modelo1) #check_model() function of the performance package
###check_model function of performance package: p-values ###
#check_collinearity(modelo1) # VIF
#check_autocorrelation(modelo1) #  Autocorrelated residuals p value
#check_heteroscedasticity(modelo1) # non-constant error variance (heteroscedasticity): p value
#check_outliers(modelo1) # Outliers method and threshold: cook
# check_normality(modelo1) # Normality of residuals p value
table_tests2<-nice_assumptions(modelo_glm1)
table_tests_fin2<-subset(table_tests2, select = -c(Model,Diagnostic) )
kable(t(table_tests_fin2)) %>%
kable_styling(bootstrap_options = "striped", full_width = F)
modelo_glm1<-glm(formula = bpsystol ~ age+sex+bmi, family = gaussian(link = log ), data = datos)
summary(modelo_glm1)
par(mfrow = c(2, 2))
plot(modelo_glm1)
#par(mfrow = c(2, 2))
#####check_model function of performance package: Grphs####
pkgs <- c(
"flextable", "performance", "see", "lmtest", "ggplot2",
"qqplotr", "ggrepel", "patchwork", "boot", "rempsyc", "report"
)
#install.packages(pkgs)
library(flextable)
library(performance)
library(see)
library(lmtest)
library(qqplotr)
library(ggrepel)
library(patchwork)
library(boot)
library(rempsyc)
library(report)
#check_model(modelo1) #check_model() function of the performance package
###check_model function of performance package: p-values ###
#check_collinearity(modelo1) # VIF
#check_autocorrelation(modelo1) #  Autocorrelated residuals p value
#check_heteroscedasticity(modelo1) # non-constant error variance (heteroscedasticity): p value
#check_outliers(modelo1) # Outliers method and threshold: cook
# check_normality(modelo1) # Normality of residuals p value
table_tests2<-nice_assumptions(modelo_glm1)
table_tests_fin2<-subset(table_tests2, select = -c(Model,Diagnostic) )
kable(t(table_tests_fin2)) %>%
kable_styling(bootstrap_options = "striped", full_width = F)
modelo_glm1<-glm(formula = bpsystol ~ age+sex+bmi, family = inverse.gaussian(link = identity), data = datos)
summary(modelo_glm1)
par(mfrow = c(2, 2))
plot(modelo_glm1)
#par(mfrow = c(2, 2))
#####check_model function of performance package: Grphs####
pkgs <- c(
"flextable", "performance", "see", "lmtest", "ggplot2",
"qqplotr", "ggrepel", "patchwork", "boot", "rempsyc", "report"
)
#install.packages(pkgs)
library(flextable)
library(performance)
library(see)
library(lmtest)
library(qqplotr)
library(ggrepel)
library(patchwork)
library(boot)
library(rempsyc)
library(report)
#check_model(modelo1) #check_model() function of the performance package
###check_model function of performance package: p-values ###
#check_collinearity(modelo1) # VIF
#check_autocorrelation(modelo1) #  Autocorrelated residuals p value
#check_heteroscedasticity(modelo1) # non-constant error variance (heteroscedasticity): p value
#check_outliers(modelo1) # Outliers method and threshold: cook
# check_normality(modelo1) # Normality of residuals p value
table_tests2<-nice_assumptions(modelo_glm1)
table_tests_fin2<-subset(table_tests2, select = -c(Model,Diagnostic) )
kable(t(table_tests_fin2)) %>%
kable_styling(bootstrap_options = "striped", full_width = F)
res<-modelo_glm1$residuals
ks.test(res, "pnorm")
res<-modelo_glm1$residuals
#ks.test(res, "pnorm")
ad.test(res)
res<-modelo_glm1$residuals
#ks.test(res, "pnorm")
library(nortest)
ad.test(res)
density(datos$bpsystol)
plot(density(datos$bpsystol))
plot(density(datos$bmi))
plot(density(datos$bpdiast))
plot(density(datos$bpsystol))
modelo_glm1<-glm(formula = bpsystol ~ age+sex+bmi, family = inverse.gaussian(link = log10), data = datos)
modelo_glm1<-glm(formula = bpsystol ~ age+sex+bmi, family = inverse.gaussian(link = log), data = datos)
summary(modelo_glm1)
par(mfrow = c(2, 2))
plot(modelo_glm1)
par(mfrow = c(2, 2))
plot(modelo_glm1)
#par(mfrow = c(2, 2))
#####check_model function of performance package: Grphs####
pkgs <- c(
"flextable", "performance", "see", "lmtest", "ggplot2",
"qqplotr", "ggrepel", "patchwork", "boot", "rempsyc", "report"
)
#install.packages(pkgs)
library(flextable)
library(performance)
library(see)
library(lmtest)
library(qqplotr)
library(ggrepel)
library(patchwork)
library(boot)
library(rempsyc)
library(report)
#check_model(modelo1) #check_model() function of the performance package
###check_model function of performance package: p-values ###
#check_collinearity(modelo1) # VIF
#check_autocorrelation(modelo1) #  Autocorrelated residuals p value
#check_heteroscedasticity(modelo1) # non-constant error variance (heteroscedasticity): p value
#check_outliers(modelo1) # Outliers method and threshold: cook
# check_normality(modelo1) # Normality of residuals p value
table_tests2<-nice_assumptions(modelo_glm1)
table_tests_fin2<-subset(table_tests2, select = -c(Model,Diagnostic) )
kable(t(table_tests_fin2)) %>%
kable_styling(bootstrap_options = "striped", full_width = F)
modelo_glm1<-glm(formula = bpsystol ~ age+sex+bmi, family = inverse.gaussian(link = identity), data = datos)
summary(modelo_glm1)
par(mfrow = c(2, 2))
plot(modelo_glm1)
#par(mfrow = c(2, 2))
#####check_model function of performance package: Grphs####
pkgs <- c(
"flextable", "performance", "see", "lmtest", "ggplot2",
"qqplotr", "ggrepel", "patchwork", "boot", "rempsyc", "report"
)
#install.packages(pkgs)
library(flextable)
library(performance)
library(see)
library(lmtest)
library(qqplotr)
library(ggrepel)
library(patchwork)
library(boot)
library(rempsyc)
library(report)
#check_model(modelo1) #check_model() function of the performance package
###check_model function of performance package: p-values ###
#check_collinearity(modelo1) # VIF
#check_autocorrelation(modelo1) #  Autocorrelated residuals p value
#check_heteroscedasticity(modelo1) # non-constant error variance (heteroscedasticity): p value
#check_outliers(modelo1) # Outliers method and threshold: cook
# check_normality(modelo1) # Normality of residuals p value
table_tests2<-nice_assumptions(modelo_glm1)
table_tests_fin2<-subset(table_tests2, select = -c(Model,Diagnostic) )
kable(t(table_tests_fin2)) %>%
kable_styling(bootstrap_options = "striped", full_width = F)
modelo_glm1<-glm(formula = bpsystol ~ age+sex+bmi, family = inverse.gaussian(link = identity), data = datos)
summary(modelo_glm1)
par(mfrow = c(2, 2))
plot(modelo_glm1)
#par(mfrow = c(2, 2))
#####check_model function of performance package: Grphs####
pkgs <- c(
"flextable", "performance", "see", "lmtest", "ggplot2",
"qqplotr", "ggrepel", "patchwork", "boot", "rempsyc", "report"
)
#install.packages(pkgs)
library(flextable)
library(performance)
library(see)
library(lmtest)
library(qqplotr)
library(ggrepel)
library(patchwork)
library(boot)
library(rempsyc)
library(report)
#check_model(modelo1) #check_model() function of the performance package
###check_model function of performance package: p-values ###
#check_collinearity(modelo1) # VIF
#check_autocorrelation(modelo1) #  Autocorrelated residuals p value
#check_heteroscedasticity(modelo1) # non-constant error variance (heteroscedasticity): p value
#check_outliers(modelo1) # Outliers method and threshold: cook
# check_normality(modelo1) # Normality of residuals p value
table_tests2<-nice_assumptions(modelo_glm1)
table_tests_fin2<-subset(table_tests2, select = -c(Model,Diagnostic) )
kable(t(table_tests_fin2)) %>%
kable_styling(bootstrap_options = "striped", full_width = F)
res<-modelo_glm1$residuals
plot(density(res))
