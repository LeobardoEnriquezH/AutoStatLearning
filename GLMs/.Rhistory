library(SuppDists)
datos<-read_csv("Preg1B.csv", show_col_types = FALSE)
datos$sex<-factor(datos$sex) #declaramos la variable como factor
#Realizamos un relevel para poner como referencia "1" hombre
datos$sex<-relevel(datos$sex,"1")
#Seleccionar un modelo entre un conjunto de posibles glm, mediante mallas
#Comp lineal: a)transf BoxTidwell(potencias) a x y b) polinomio sobre x
#Mallas para el valor de potencia y grado de polinomio:
malla=seq(from = 1, to = 5, by = 1)
Poli <- cbind("poly", malla)
malla=seq(from = -3, to = 3, by = .5)
Pot <- cbind("pot", malla)
CompLin=rbind(Poli, Pot)
#Componente aleatorio: Y es continua y positiva, tenemos tres opciones:
#Malla con distribucion Normal, Gausiana e Inversa Gausiana
Distribuciones=c("gaussian", "Gamma", "inverse.gaussian")
#Funcion liga:inverse, identity, log, y 1/mu^2(solo para IG)
FunLigas=c("identity", "log", "inverse", "1/mu^2")
#Declaramos longitud o dimensión de los vectores
nFunLigas=length(FunLigas)
nDist=length(Distribuciones)
nCompLin=dim(CompLin)[1]
#Creación de variables para guardar resultados
ModelList=list(NA)  #guardar resultados del ajuste, objeto glm
AICList=list(NA)    #guardar el AIC del modelo
BICList=list(NA)    #guardar el BIC del modelo
FormList=list(NA)   #guardar la formula usada para el ajuste
#Modelos 18*2*3+18*1*4(tres funciones ligas para 2 distrib y 4 para una, IG)
#Generamos los cíclos y combinaciones de las mallas
index=0
for(k in 1:nCompLin){
#definimos componente lineal y formula
if(CompLin[k,1]=="poly"){
formstring=paste0("bpsystol ~ age+sex+poly(bmi,",  CompLin[k,2], ", raw=TRUE)")
}else{
if(CompLin[k,2]==0){
formstring=paste0("bpsystol ~ age+sex+I(log(bmi))")}else
{
formstring=paste0("bpsystol ~ age+sex+I(bmi^(",  CompLin[k,2], "))")}
}
form <- as.formula(formstring)
for(j in 1:nDist){
for(l in 1:nFunLigas){
#definicion del argumento family
if(FunLigas[l]=="1/mu^2"){
if(Distribuciones[j]=="inverse.gaussian"){
index=index+1
Dist=get(Distribuciones[j])  #obtener la funcion a usar
Mod.A.Prueba=glm(form, data=datos, family = Dist(link=FunLigas[l]))
ModelList[[index]]=Mod.A.Prueba
AICList[[index]]=AIC(Mod.A.Prueba)
BICList[[index]]=BIC(Mod.A.Prueba)
FormList[[index]]=formstring
}
}else{
index=index+1
Dist=get(Distribuciones[j])
Mod.A.Prueba=glm(form, data=datos, family = Dist(link=FunLigas[l]))
ModelList[[index]]=Mod.A.Prueba
AICList[[index]]=AIC(Mod.A.Prueba)
BICList[[index]]=BIC(Mod.A.Prueba)
FormList[[index]]=formstring
}
}
}
}
#El modelo con menor AIC
MinAIC=which.min(unlist(AICList))
ModMinAIC=ModelList[[MinAIC]]
#summary(ModMinAIC)
#Mostrar los AIC, BIC, modelo y liga
ModMinAIC$family
AICList[[MinAIC]]
BICList[[MinAIC]]
FormList[[MinAIC]]
modelo_glm1<-glm(formula = bpsystol ~ age+sex+bmi, family = inverse.gaussian(link = identity), data = datos)
#summary(modelo_glm1)
#stargazer(ModMinAIC, modelo_glm1)
K=matrix(c(0,1,0,0,
0,0,1,0,
0,0,0,1), ncol=4, nrow=3, byrow=TRUE)
m=c(0,0,0)
summary(glht(modelo_glm1, linfct=K, rhs=m), test=Chisqtest())
# Se incluye cierta aleatorización para datos binarios
library(statmod)
fitlogitqr <- qresid(modelo_glm1)
#qqnorm( fitlogitqr, las=1 ); qqline( fitlogitqr)
lilKS<-nortest::lillie.test(fitlogitqr)
Shapiro<-shapiro.test(fitlogitqr)
resid_panel(modelo_glm1, plots=c("all"),scale = 1)
set.seed(123)
fit2res <- simulateResiduals(fittedModel = modelo_glm1)
plot(fit2res)
K=matrix(c(0,0,0,1), ncol=4, nrow=1, byrow=TRUE)
m=0
prueba<-glht(modelo_glm1, linfct=K, rhs=m, alternative="greater")
#summary(prueba)
curva_ajustada_mujer30 <- function(x) {modelo_glm1$coefficients[1] + modelo_glm1$coefficients[4]*x + modelo_glm1$coefficients[3] + modelo_glm1$coefficients[2]*30}
curva_ajustada_hombre30 <- function(x) {modelo_glm1$coefficients[1] + modelo_glm1$coefficients[4]*x  + modelo_glm1$coefficients[2]*30}
curva_ajustada_mujer50 <- function(x) {modelo_glm1$coefficients[1] + modelo_glm1$coefficients[4]*x + modelo_glm1$coefficients[3] + modelo_glm1$coefficients[2]*50}
curva_ajustada_hombre50 <- function(x) {modelo_glm1$coefficients[1] + modelo_glm1$coefficients[4]*x  + modelo_glm1$coefficients[2]*50}
curva_ajustada_mujer64 <- function(x) {modelo_glm1$coefficients[1] + modelo_glm1$coefficients[4]*x + modelo_glm1$coefficients[3] + modelo_glm1$coefficients[2]*64}
curva_ajustada_hombre64 <- function(x) {modelo_glm1$coefficients[1] + modelo_glm1$coefficients[4]*x  + modelo_glm1$coefficients[2]*64}
ggplot(datos, aes(bmi, bpsystol)) +
geom_point() +
geom_function(fun = curva_ajustada_mujer30, aes(linetype = "mujer de 30") ,col="skyblue", lwd = 1) +
geom_function(fun = curva_ajustada_hombre30, aes(linetype = "hombre de 30") ,col="green") +
geom_function(fun = curva_ajustada_mujer50, aes(linetype = "mujer de 50") ,col="darkblue", lwd = 0.8) +
geom_function(fun = curva_ajustada_hombre50, aes(linetype = "hombre de 50") ,col="darkgreen") +
geom_function(fun = curva_ajustada_mujer64, aes(linetype = "mujer de 64") ,col="red") +
geom_function(fun = curva_ajustada_hombre64, aes(linetype = "hombre de 64") ,col="magenta") + theme_bw()
#Modelo Reg Lineal con logaritmos
modelo2=lm(data=datos, I(log(bpsystol)) ~ bmi + sex + age)
#summary(modelo2)
#summary(modelo_glm1)
#stargazer(modelo2, modelo_glm1)
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(stargazer)
library(kableExtra)
library(flextable)
library(performance)
library(see)
library(lmtest)
library(qqplotr)
library(ggrepel)
library(patchwork)
library(boot)
library(rempsyc)
library(report)
library(multcomp)
library(ggplot2)
library(ggResidpanel)
library(DHARMa)
library(SuppDists)
datos<-read_csv("Preg1B.csv", show_col_types = FALSE)
datos$sex<-factor(datos$sex) #declaramos la variable como factor
#Realizamos un relevel para poner como referencia "1" hombre
datos$sex<-relevel(datos$sex,"1")
#Seleccionar un modelo entre un conjunto de posibles glm, mediante mallas
#Comp lineal: a)transf BoxTidwell(potencias) a x y b) polinomio sobre x
#Mallas para el valor de potencia y grado de polinomio:
malla=seq(from = 1, to = 5, by = 1)
Poli <- cbind("poly", malla)
malla=seq(from = -3, to = 3, by = .5)
Pot <- cbind("pot", malla)
CompLin=rbind(Poli, Pot)
#Componente aleatorio: Y es continua y positiva, tenemos tres opciones:
#Malla con distribucion Normal, Gausiana e Inversa Gausiana
Distribuciones=c("gaussian", "Gamma", "inverse.gaussian")
#Funcion liga:inverse, identity, log, y 1/mu^2(solo para IG)
FunLigas=c("identity", "log", "inverse", "1/mu^2")
#Declaramos longitud o dimensión de los vectores
nFunLigas=length(FunLigas)
nDist=length(Distribuciones)
nCompLin=dim(CompLin)[1]
#Creación de variables para guardar resultados
ModelList=list(NA)  #guardar resultados del ajuste, objeto glm
AICList=list(NA)    #guardar el AIC del modelo
BICList=list(NA)    #guardar el BIC del modelo
FormList=list(NA)   #guardar la formula usada para el ajuste
#Modelos 18*2*3+18*1*4(tres funciones ligas para 2 distrib y 4 para una, IG)
#Generamos los cíclos y combinaciones de las mallas
index=0
for(k in 1:nCompLin){
#definimos componente lineal y formula
if(CompLin[k,1]=="poly"){
formstring=paste0("bpsystol ~ age+sex+poly(bmi,",  CompLin[k,2], ", raw=TRUE)")
}else{
if(CompLin[k,2]==0){
formstring=paste0("bpsystol ~ age+sex+I(log(bmi))")}else
{
formstring=paste0("bpsystol ~ age+sex+I(bmi^(",  CompLin[k,2], "))")}
}
form <- as.formula(formstring)
for(j in 1:nDist){
for(l in 1:nFunLigas){
#definicion del argumento family
if(FunLigas[l]=="1/mu^2"){
if(Distribuciones[j]=="inverse.gaussian"){
index=index+1
Dist=get(Distribuciones[j])  #obtener la funcion a usar
Mod.A.Prueba=glm(form, data=datos, family = Dist(link=FunLigas[l]))
ModelList[[index]]=Mod.A.Prueba
AICList[[index]]=AIC(Mod.A.Prueba)
BICList[[index]]=BIC(Mod.A.Prueba)
FormList[[index]]=formstring
}
}else{
index=index+1
Dist=get(Distribuciones[j])
Mod.A.Prueba=glm(form, data=datos, family = Dist(link=FunLigas[l]))
ModelList[[index]]=Mod.A.Prueba
AICList[[index]]=AIC(Mod.A.Prueba)
BICList[[index]]=BIC(Mod.A.Prueba)
FormList[[index]]=formstring
}
}
}
}
#Generamos los cíclos y combinaciones de las mallas
index=0
for(k in 1:nCompLin){
#definimos componente lineal y formula
if(CompLin[k,1]=="poly"){
formstring=paste0("bpsystol ~ age+sex+poly(bmi,",  CompLin[k,2], ", raw=TRUE)")
}else{
if(CompLin[k,2]==0){
formstring=paste0("bpsystol ~ age+sex+I(log(bmi))")}else
{
formstring=paste0("bpsystol ~ age+sex+I(bmi^(",  CompLin[k,2], "))")}
}
form <- as.formula(formstring)
for(j in 1:nDist){
for(l in 1:nFunLigas){
#definicion del argumento family
if(FunLigas[l]=="1/mu^2"){
if(Distribuciones[j]=="inverse.gaussian"){
index=index+1
Dist=get(Distribuciones[j])  #obtener la funcion a usar
Mod.A.Prueba=glm(form, data=datos, family = Dist(link=FunLigas[l]))
ModelList[[index]]=Mod.A.Prueba
AICList[[index]]=AIC(Mod.A.Prueba)
BICList[[index]]=BIC(Mod.A.Prueba)
FormList[[index]]=formstring
}
}else{
index=index+1
Dist=get(Distribuciones[j])
Mod.A.Prueba=glm(form, data=datos, family = Dist(link=FunLigas[l]))
ModelList[[index]]=Mod.A.Prueba
AICList[[index]]=AIC(Mod.A.Prueba)
BICList[[index]]=BIC(Mod.A.Prueba)
FormList[[index]]=formstring
}
}
}
}
#El modelo con menor AIC
MinAIC=which.min(unlist(AICList))
ModMinAIC=ModelList[[MinAIC]]
#summary(ModMinAIC)
#Mostrar los AIC, BIC, modelo y liga
ModMinAIC$family
AICList[[MinAIC]]
BICList[[MinAIC]]
FormList[[MinAIC]]
modelo_glm1<-glm(formula = bpsystol ~ age+sex+bmi, family = inverse.gaussian(link = identity), data = datos)
#summary(modelo_glm1)
#stargazer(ModMinAIC, modelo_glm1)
K=matrix(c(0,1,0,0,
0,0,1,0,
0,0,0,1), ncol=4, nrow=3, byrow=TRUE)
m=c(0,0,0)
summary(glht(modelo_glm1, linfct=K, rhs=m), test=Chisqtest())
# Se incluye cierta aleatorización para datos binarios
library(statmod)
fitlogitqr <- qresid(modelo_glm1)
#qqnorm( fitlogitqr, las=1 ); qqline( fitlogitqr)
lilKS<-nortest::lillie.test(fitlogitqr)
Shapiro<-shapiro.test(fitlogitqr)
resid_panel(modelo_glm1, plots=c("all"),scale = 1)
set.seed(123)
fit2res <- simulateResiduals(fittedModel = modelo_glm1)
plot(fit2res)
K=matrix(c(0,0,0,1), ncol=4, nrow=1, byrow=TRUE)
m=0
prueba<-glht(modelo_glm1, linfct=K, rhs=m, alternative="greater")
#summary(prueba)
curva_ajustada_mujer30 <- function(x) {modelo_glm1$coefficients[1] + modelo_glm1$coefficients[4]*x + modelo_glm1$coefficients[3] + modelo_glm1$coefficients[2]*30}
curva_ajustada_hombre30 <- function(x) {modelo_glm1$coefficients[1] + modelo_glm1$coefficients[4]*x  + modelo_glm1$coefficients[2]*30}
curva_ajustada_mujer50 <- function(x) {modelo_glm1$coefficients[1] + modelo_glm1$coefficients[4]*x + modelo_glm1$coefficients[3] + modelo_glm1$coefficients[2]*50}
curva_ajustada_hombre50 <- function(x) {modelo_glm1$coefficients[1] + modelo_glm1$coefficients[4]*x  + modelo_glm1$coefficients[2]*50}
curva_ajustada_mujer64 <- function(x) {modelo_glm1$coefficients[1] + modelo_glm1$coefficients[4]*x + modelo_glm1$coefficients[3] + modelo_glm1$coefficients[2]*64}
curva_ajustada_hombre64 <- function(x) {modelo_glm1$coefficients[1] + modelo_glm1$coefficients[4]*x  + modelo_glm1$coefficients[2]*64}
ggplot(datos, aes(bmi, bpsystol)) +
geom_point() +
geom_function(fun = curva_ajustada_mujer30, aes(linetype = "mujer de 30") ,col="skyblue", lwd = 1) +
geom_function(fun = curva_ajustada_hombre30, aes(linetype = "hombre de 30") ,col="green") +
geom_function(fun = curva_ajustada_mujer50, aes(linetype = "mujer de 50") ,col="darkblue", lwd = 0.8) +
geom_function(fun = curva_ajustada_hombre50, aes(linetype = "hombre de 50") ,col="darkgreen") +
geom_function(fun = curva_ajustada_mujer64, aes(linetype = "mujer de 64") ,col="red") +
geom_function(fun = curva_ajustada_hombre64, aes(linetype = "hombre de 64") ,col="magenta") + theme_bw()
#Modelo Reg Lineal con logaritmos
modelo2=lm(data=datos, I(log(bpsystol)) ~ bmi + sex + age)
#summary(modelo2)
#summary(modelo_glm1)
#stargazer(modelo2, modelo_glm1)
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(stargazer)
library(kableExtra)
library(flextable)
library(performance)
library(see)
library(lmtest)
library(qqplotr)
library(ggrepel)
library(patchwork)
library(boot)
library(rempsyc)
library(report)
library(multcomp)
library(ggplot2)
library(ggResidpanel)
library(DHARMa)
library(SuppDists)
datos<-read_csv("Preg1B.csv", show_col_types = FALSE)
datos$sex<-factor(datos$sex) #declaramos la variable como factor
#Realizamos un relevel para poner como referencia "1" hombre
datos$sex<-relevel(datos$sex,"1")
#Seleccionar un modelo entre un conjunto de posibles glm, mediante mallas
#Comp lineal: a)transf BoxTidwell(potencias) a x y b) polinomio sobre x
#Mallas para el valor de potencia y grado de polinomio:
malla=seq(from = 1, to = 5, by = 1)
Poli <- cbind("poly", malla)
malla=seq(from = -3, to = 3, by = .5)
Pot <- cbind("pot", malla)
CompLin=rbind(Poli, Pot)
#Componente aleatorio: Y es continua y positiva, tenemos tres opciones:
#Malla con distribucion Normal, Gausiana e Inversa Gausiana
Distribuciones=c("gaussian", "Gamma", "inverse.gaussian")
#Funcion liga:inverse, identity, log, y 1/mu^2(solo para IG)
FunLigas=c("identity", "log", "inverse", "1/mu^2")
#Declaramos longitud o dimensión de los vectores
nFunLigas=length(FunLigas)
nDist=length(Distribuciones)
nCompLin=dim(CompLin)[1]
#Creación de variables para guardar resultados
ModelList=list(NA)  #guardar resultados del ajuste, objeto glm
AICList=list(NA)    #guardar el AIC del modelo
BICList=list(NA)    #guardar el BIC del modelo
FormList=list(NA)   #guardar la formula usada para el ajuste
#Modelos 18*2*3+18*1*4(tres funciones ligas para 2 distrib y 4 para una, IG)
#Generamos los cíclos y combinaciones de las mallas
index=0
for(k in 1:nCompLin){
#definimos componente lineal y formula
if(CompLin[k,1]=="poly"){
formstring=paste0("bpsystol ~ age+sex+poly(bmi,",  CompLin[k,2], ", raw=TRUE)")
}else{
if(CompLin[k,2]==0){
formstring=paste0("bpsystol ~ age+sex+I(log(bmi))")}else
{
formstring=paste0("bpsystol ~ age+sex+I(bmi^(",  CompLin[k,2], "))")}
}
form <- as.formula(formstring)
for(j in 1:nDist){
for(l in 1:nFunLigas){
#definicion del argumento family
if(FunLigas[l]=="1/mu^2"){
if(Distribuciones[j]=="inverse.gaussian"){
index=index+1
Dist=get(Distribuciones[j])  #obtener la funcion a usar
Mod.A.Prueba=glm(form, data=datos, family = Dist(link=FunLigas[l]))
ModelList[[index]]=Mod.A.Prueba
AICList[[index]]=AIC(Mod.A.Prueba)
BICList[[index]]=BIC(Mod.A.Prueba)
FormList[[index]]=formstring
}
}else{
index=index+1
Dist=get(Distribuciones[j])
Mod.A.Prueba=glm(form, data=datos, family = Dist(link=FunLigas[l]))
ModelList[[index]]=Mod.A.Prueba
AICList[[index]]=AIC(Mod.A.Prueba)
BICList[[index]]=BIC(Mod.A.Prueba)
FormList[[index]]=formstring
}
}
}
}
#El modelo con menor AIC
MinAIC=which.min(unlist(AICList))
ModMinAIC=ModelList[[MinAIC]]
#summary(ModMinAIC)
#Mostrar los AIC, BIC, modelo y liga
ModMinAIC$family
AICList[[MinAIC]]
BICList[[MinAIC]]
FormList[[MinAIC]]
modelo_glm1<-glm(formula = bpsystol ~ age+sex+bmi, family = inverse.gaussian(link = identity), data = datos)
#summary(modelo_glm1)
#stargazer(ModMinAIC, modelo_glm1)
K=matrix(c(0,1,0,0,
0,0,1,0,
0,0,0,1), ncol=4, nrow=3, byrow=TRUE)
m=c(0,0,0)
summary(glht(modelo_glm1, linfct=K, rhs=m), test=Chisqtest())
# Se incluye cierta aleatorización para datos binarios
library(statmod)
fitlogitqr <- qresid(modelo_glm1)
#qqnorm( fitlogitqr, las=1 ); qqline( fitlogitqr)
lilKS<-nortest::lillie.test(fitlogitqr)
Shapiro<-shapiro.test(fitlogitqr)
resid_panel(modelo_glm1, plots=c("all"),scale = 1)
set.seed(123)
fit2res <- simulateResiduals(fittedModel = modelo_glm1)
plot(fit2res)
K=matrix(c(0,0,0,1), ncol=4, nrow=1, byrow=TRUE)
m=0
prueba<-glht(modelo_glm1, linfct=K, rhs=m, alternative="greater")
#summary(prueba)
curva_ajustada_mujer30 <- function(x) {modelo_glm1$coefficients[1] + modelo_glm1$coefficients[4]*x + modelo_glm1$coefficients[3] + modelo_glm1$coefficients[2]*30}
curva_ajustada_hombre30 <- function(x) {modelo_glm1$coefficients[1] + modelo_glm1$coefficients[4]*x  + modelo_glm1$coefficients[2]*30}
curva_ajustada_mujer50 <- function(x) {modelo_glm1$coefficients[1] + modelo_glm1$coefficients[4]*x + modelo_glm1$coefficients[3] + modelo_glm1$coefficients[2]*50}
curva_ajustada_hombre50 <- function(x) {modelo_glm1$coefficients[1] + modelo_glm1$coefficients[4]*x  + modelo_glm1$coefficients[2]*50}
curva_ajustada_mujer64 <- function(x) {modelo_glm1$coefficients[1] + modelo_glm1$coefficients[4]*x + modelo_glm1$coefficients[3] + modelo_glm1$coefficients[2]*64}
curva_ajustada_hombre64 <- function(x) {modelo_glm1$coefficients[1] + modelo_glm1$coefficients[4]*x  + modelo_glm1$coefficients[2]*64}
ggplot(datos, aes(bmi, bpsystol)) +
geom_point() +
geom_function(fun = curva_ajustada_mujer30, aes(linetype = "mujer de 30") ,col="skyblue", lwd = 1) +
geom_function(fun = curva_ajustada_hombre30, aes(linetype = "hombre de 30") ,col="green") +
geom_function(fun = curva_ajustada_mujer50, aes(linetype = "mujer de 50") ,col="darkblue", lwd = 0.8) +
geom_function(fun = curva_ajustada_hombre50, aes(linetype = "hombre de 50") ,col="darkgreen") +
geom_function(fun = curva_ajustada_mujer64, aes(linetype = "mujer de 64") ,col="red") +
geom_function(fun = curva_ajustada_hombre64, aes(linetype = "hombre de 64") ,col="magenta") + theme_bw()
#Modelo Reg Lineal con logaritmos
modelo2=lm(data=datos, I(log(bpsystol)) ~ bmi + sex + age)
#summary(modelo2)
#summary(modelo_glm1)
#stargazer(modelo2, modelo_glm1)
knitr::opts_chunk$set(echo = TRUE,message = F,warning = F,fig.width = 5, fig.height = 2.9)
library(tidyverse)
library(kableExtra)
library(ggplot2)
library(cowplot)
library(stargazer)
library(knitr)
library(dplyr)
library(readr)
library(car)
library(MASS)
library(ggResidpanel)
library(DHARMa)
data4 <- read_csv("Preg4.csv")
#Primero haremos factor las variables de ciudad y edad
data4$City <- as.factor(data4$City)
#Tambien crearemos la variable que indicara la tasa de incidencia
data4$incidencia <- data4$Cases/data4$Pop
ggplot(data=data4, aes(x=Age,y=incidencia, colour=City))+ geom_point()+ theme_classic()+
theme(text = element_text(size = 11),element_line(linewidth =0.5))
fit_poisson <- glm(Cases ~ incidencia + Age * City, data = data4, family = poisson(link = "log"))
summary(fit_poisson)
#Toda esta parte de verificacion de supuestos del primer modelo se omitira en el pdf pero se dejara aqui en codigo
#Ya que ajustamos el primer modelo comenzaremos a verificar los supuestos del mismo. Para comenzar realizaremos la prueba de dedo para ver si se cumple el supuesto de la media igual a la varianza.
#Ya que ajustamos el primer modelo comenzaremos a verificar los supuestos del mismo. Para comenzar realizaremos la prueba de dedo para ver si se cumple el supuesto de la media igual a la varianza.
#deviance(fit_poisson)/df.residual(fit_poisson)
#En este caso tenemos un valor muy alejado de 1 lo cual nos indica que este supuesto no se esta cumpliendo, es decir, tenemos que la media no es igual a la varianza.
#Veamos como se comportan los demás supuestos.
#resid_panel(fit_poisson, plots=c("all"))
#set.seed(123)
#fit1res <- simulateResiduals(fittedModel = fit_poisson)
#plot(fit1res )
fit_poisson2 <- glm(Cases ~ I(incidencia^1.8) + Age , data = data4, family = poisson(link = "log"))
summary(fit_poisson2)
deviance(fit_poisson2)/df.residual(fit_poisson2)
#se omitiran las graficas en panel por motivos de espacio
#resid_panel(fit_poisson2, plots=c("all"))
#set.seed(123)
fit1res2 <- simulateResiduals(fittedModel = fit_poisson2)
plot(fit1res2)
par(mfrow = c(2, 2))
anova(fit_poisson,fit_poisson2, test = "Chisq")
fit_negbin <- glm.nb(Cases ~ incidencia + Age , data = data4, link = "log")
summary(fit_negbin)
#Verifiquemos los supuestos de este modelo con DHARMa
#En este caso nuevamente omitiremos los resultados de las pruebas de los supuestos para este modelo ya que no se usara debido a que se escogio como mejor ajuste el modelo anterior
#set.seed(123)
#fit_negativ <- simulateResiduals(fittedModel = fit_negbin)
#plot(fit_negativ)
#Podemos decir que este también parece ser buen modelo, al menos es mucho mejor #que el primero, sin embargo no parece ser mejor que el segundo modelo.
#Comparemos los AIC y BIC de los ultimos 2 modelos para ver cual es mejor en este #aspecto.
c(AIC(fit_poisson2), AIC(fit_negbin))
c(BIC(fit_poisson2), BIC(fit_negbin))
#Para los intervalos de confianza lo que haremos sera definir una malla de valores para la edad ya que nos interesa saber si a mayor edad existe mayor incidencia de cancer de pulmon
library(MASS)
edad <- seq(from = 40, to =74, by = .5)
#el calculo de los intervalos los haremos a una confianza del 95%
#E(y;x)= b0 + b1 incidencia^1.8  + b2 Age
library(multcomp)
k <- cbind(0,0,0,0,-1,-edad)
#banda del primer grupo de edad
fite <- glht(fit_poisson2, linfct = k)
fitci2 <- confint(fite, level = 0.95)
plot(edad, coef(fite), col="black", type="l", main="Incidencia de Cáncer por Edad")+
lines(edad, fitci2$confint[,"upr"], col="black")+
lines(edad, fitci2$confint[,"lwr"], col="black")+
abline(h=25, col="blue")
knitr::opts_chunk$set(echo = TRUE,message = F,warning = F,fig.width = 5, fig.height = 2.9)
library(tidyverse)
library(kableExtra)
library(ggplot2)
library(cowplot)
library(stargazer)
library(knitr)
library(dplyr)
library(readr)
library(car)
library(MASS)
library(ggResidpanel)
library(DHARMa)
data4 <- read_csv("Preg4.csv")
#Primero haremos factor las variables de ciudad y edad
data4$City <- as.factor(data4$City)
#Tambien crearemos la variable que indicara la tasa de incidencia
data4$incidencia <- data4$Cases/data4$Pop
ggplot(data=data4, aes(x=Age,y=incidencia, colour=City))+ geom_point()+ theme_classic()+
theme(text = element_text(size = 11),element_line(linewidth =0.5))
fit_poisson <- glm(Cases ~ incidencia + Age * City, data = data4, family = poisson(link = "log"))
summary(fit_poisson)
View(data4)
